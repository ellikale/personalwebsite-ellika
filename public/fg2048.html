<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FG 2048 • Ellika LeSage</title>
    <style media="screen">
      :root {
        --sky: #8faec0;
        --deep-sky: #698da5;
        --emerald: #1d8a66;
        --pine: #0f4333;
        --frost: rgba(255, 255, 255, 0.9);
        --frost-muted: rgba(255, 255, 255, 0.6);
        --panel: rgba(9, 39, 55, 0.4);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--frost);
        background: linear-gradient(135deg, var(--sky) 0%, var(--deep-sky) 45%, #0c2d46 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        scroll-behavior: smooth;
      }

      main {
        width: min(960px, 92vw);
        padding: 96px 0 120px;
      }

      header.hero {
        text-align: center;
        margin-bottom: 36px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
      }

      header.hero h1 {
        font-size: clamp(3.4rem, 8vw, 4.6rem);
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        margin: 0;
      }

      nav {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 24px;
      }

      nav a {
        color: var(--frost);
        text-decoration: none;
        font-weight: 600;
        letter-spacing: 0.06em;
        padding: 10px 18px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.08);
        transition: transform 180ms ease, background 180ms ease, border-color 180ms ease;
      }

      nav a:hover,
      nav a:focus {
        border-color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-2px);
      }

      .game-container {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 28px;
        padding: clamp(32px, 6vw, 48px);
        backdrop-filter: blur(12px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.28);
        margin-bottom: 36px;
      }

      .heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 16px;
      }

      .title {
        font-size: clamp(2rem, 4.5vw, 2.4rem);
        margin: 0;
        letter-spacing: 0.03em;
      }

      .scores-container {
        display: flex;
        gap: 12px;
      }

      .score-box {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 12px 20px;
        text-align: center;
        min-width: 100px;
      }

      .score-box .score-label {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--frost-muted);
        margin-bottom: 4px;
      }

      .score-box .score-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--frost);
      }

      .above-game {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 16px;
      }

      .game-intro {
        font-size: clamp(1rem, 2.6vw, 1.12rem);
        color: var(--frost-muted);
        margin: 0;
      }

      .restart-button {
        background: var(--emerald);
        color: var(--frost);
        border: none;
        border-radius: 12px;
        padding: 12px 24px;
        font-size: clamp(1rem, 2.6vw, 1.12rem);
        font-weight: 600;
        letter-spacing: 0.05em;
        cursor: pointer;
        transition: transform 180ms ease, background 180ms ease, box-shadow 180ms ease;
        box-shadow: 0 4px 12px rgba(29, 138, 102, 0.3);
        font-family: inherit;
      }

      .restart-button:hover,
      .restart-button:focus {
        transform: translateY(-2px);
        background: #1a7a5a;
        box-shadow: 0 6px 16px rgba(29, 138, 102, 0.4);
      }

      .game-message {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(9, 39, 55, 0.95);
        z-index: 100;
        text-align: center;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 28px;
        animation: fadeIn 0.3s;
      }

      .game-message p {
        font-size: clamp(1.5rem, 4vw, 2rem);
        font-weight: 700;
        margin: 0 0 16px 0;
        color: var(--frost);
      }

      .game-message .lower {
        display: block;
        margin-top: 16px;
      }

      .game-message.game-won {
        background: rgba(29, 138, 102, 0.95);
      }

      .game-message.game-won .lower {
        display: block;
      }

      .game-message.game-over {
        background: rgba(220, 53, 69, 0.95);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .container {
        position: relative;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
      }

      .game-layout {
        display: flex;
        gap: clamp(24px, 5vw, 48px);
        align-items: flex-start;
        flex-wrap: wrap;
      }

      .game-layout .container {
        flex: 1 1 340px;
      }

      .leaderboard-panel {
        flex: 0 0 280px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 24px;
        padding: 24px;
        box-shadow: 0 20px 35px rgba(0, 0, 0, 0.28);
        backdrop-filter: blur(12px);
        color: var(--frost);
        min-height: 100%;
      }

      .leaderboard-header {
        margin-bottom: 16px;
      }

      .leaderboard-header h2 {
        margin: 0;
        font-size: 1.4rem;
        letter-spacing: 0.04em;
      }

      .leaderboard-subtitle {
        margin: 4px 0 0;
        font-size: 0.9rem;
        color: var(--frost-muted);
      }

      .leaderboard-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .leaderboard-entry {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
        padding: 8px 0 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      }

      .leaderboard-entry:last-child {
        border-bottom: none;
      }

      .leaderboard-label {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }

      .leaderboard-rank {
        font-weight: 700;
        color: var(--emerald);
        min-width: 24px;
      }

      .leaderboard-meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .leaderboard-name {
        font-weight: 600;
        letter-spacing: 0.03em;
      }

      .leaderboard-timestamp {
        font-size: 0.85rem;
        color: var(--frost-muted);
      }

      .leaderboard-score {
        font-weight: 700;
        font-size: 1.1rem;
      }

      .leaderboard-empty {
        margin: 12px 0 0;
        font-size: 0.95rem;
        color: var(--frost-muted);
        text-align: center;
      }

      .grid-container {
        position: relative;
        padding: 15px;
        background: rgba(9, 39, 55, 0.6);
        border-radius: 12px;
        margin: 0 auto;
        z-index: 1;
      }

      .tile-container {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        bottom: 15px;
        z-index: 2;
        pointer-events: none;
      }

      .tile-container .tile {
        pointer-events: none;
      }

      .grid-row {
        display: flex;
        margin-bottom: 15px;
      }

      .grid-row:last-child {
        margin-bottom: 0;
      }

      .grid-cell {
        width: 106.25px;
        height: 106.25px;
        margin-right: 15px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.1);
      }

      .grid-row:last-child .grid-cell {
        margin-bottom: 0;
      }

      .grid-row .grid-cell:last-child {
        margin-right: 0;
      }

      .tile {
        position: absolute;
        width: 106.25px;
        height: 106.25px;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border-radius: 6px;
        font-weight: 700;
        text-align: center;
        line-height: 106.25px;
        font-size: 55px;
        transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.15s;
      }

      .tile-inner {
        width: 100%;
        height: 100%;
        opacity: 0;
      }

      /* Tile position classes */
      .tile-position-1-1 { transform: translate(0, 0); }
      .tile-position-1-2 { transform: translate(0, 121.25px); }
      .tile-position-1-3 { transform: translate(0, 242.5px); }
      .tile-position-1-4 { transform: translate(0, 363.75px); }
      .tile-position-2-1 { transform: translate(121.25px, 0); }
      .tile-position-2-2 { transform: translate(121.25px, 121.25px); }
      .tile-position-2-3 { transform: translate(121.25px, 242.5px); }
      .tile-position-2-4 { transform: translate(121.25px, 363.75px); }
      .tile-position-3-1 { transform: translate(242.5px, 0); }
      .tile-position-3-2 { transform: translate(242.5px, 121.25px); }
      .tile-position-3-3 { transform: translate(242.5px, 242.5px); }
      .tile-position-3-4 { transform: translate(242.5px, 363.75px); }
      .tile-position-4-1 { transform: translate(363.75px, 0); }
      .tile-position-4-2 { transform: translate(363.75px, 121.25px); }
      .tile-position-4-3 { transform: translate(363.75px, 242.5px); }
      .tile-position-4-4 { transform: translate(363.75px, 363.75px); }

      .tile.new {
        animation: appear 0.2s;
      }

      .tile.merged {
        z-index: 20;
        animation: pop 0.15s;
      }

      @keyframes appear {
        0% {
          opacity: 0;
          transform: scale(0);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes pop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Tile value to image mapping */
      .tile.tile-2 { background-image: url('FG 2048/2.png'); }
      .tile.tile-4 { background-image: url('FG 2048/4.png'); }
      .tile.tile-8 { background-image: url('FG 2048/8.png'); }
      .tile.tile-16 { background-image: url('FG 2048/16.png'); }
      .tile.tile-32 { background-image: url('FG 2048/32.png'); }
      .tile.tile-64 { background-image: url('FG 2048/64.png'); }
      .tile.tile-128 { background-image: url('FG 2048/128.png'); }
      .tile.tile-256 { background-image: url('FG 2048/256.png'); }
      .tile.tile-512 { background-image: url('FG 2048/512.png'); }
      .tile.tile-1024 { background-image: url('FG 2048/1024.png'); }
      .tile.tile-2048 { background-image: url('FG 2048/2048.png'); }

      /* Fallback for higher values - use 2048 image */
      .tile[class*="tile-"]:not(.tile-2):not(.tile-4):not(.tile-8):not(.tile-16):not(.tile-32):not(.tile-64):not(.tile-128):not(.tile-256):not(.tile-512):not(.tile-1024):not(.tile-2048) {
        background-image: url('FG 2048/2048.png');
      }

      @media (max-width: 900px) {
        .game-layout {
          flex-direction: column;
        }

        .leaderboard-panel {
          flex: 1 1 100%;
          width: 100%;
        }
      }

      @media (max-width: 720px) {
        nav {
          flex-wrap: wrap;
          gap: 12px;
        }

        .grid-cell,
        .tile {
          width: 65px;
          height: 65px;
          line-height: 65px;
          font-size: 35px;
        }

        .grid-container {
          padding: 10px;
        }

        .tile-container {
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: 10px;
        }

        .grid-row {
          margin-bottom: 10px;
        }

        .grid-cell {
          margin-right: 10px;
        }

        /* Mobile tile positions */
        .tile-position-1-1 { transform: translate(0, 0); }
        .tile-position-1-2 { transform: translate(0, 75px); }
        .tile-position-1-3 { transform: translate(0, 150px); }
        .tile-position-1-4 { transform: translate(0, 225px); }
        .tile-position-2-1 { transform: translate(75px, 0); }
        .tile-position-2-2 { transform: translate(75px, 75px); }
        .tile-position-2-3 { transform: translate(75px, 150px); }
        .tile-position-2-4 { transform: translate(75px, 225px); }
        .tile-position-3-1 { transform: translate(150px, 0); }
        .tile-position-3-2 { transform: translate(150px, 75px); }
        .tile-position-3-3 { transform: translate(150px, 150px); }
        .tile-position-3-4 { transform: translate(150px, 225px); }
        .tile-position-4-1 { transform: translate(225px, 0); }
        .tile-position-4-2 { transform: translate(225px, 75px); }
        .tile-position-4-3 { transform: translate(225px, 150px); }
        .tile-position-4-4 { transform: translate(225px, 225px); }
      }

      @media (max-width: 480px) {
        .grid-cell,
        .tile {
          width: 55px;
          height: 55px;
          line-height: 55px;
          font-size: 30px;
        }

        .tile-container {
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: 10px;
        }

        /* Small mobile tile positions */
        .tile-position-1-1 { transform: translate(0, 0); }
        .tile-position-1-2 { transform: translate(0, 65px); }
        .tile-position-1-3 { transform: translate(0, 130px); }
        .tile-position-1-4 { transform: translate(0, 195px); }
        .tile-position-2-1 { transform: translate(65px, 0); }
        .tile-position-2-2 { transform: translate(65px, 65px); }
        .tile-position-2-3 { transform: translate(65px, 130px); }
        .tile-position-2-4 { transform: translate(65px, 195px); }
        .tile-position-3-1 { transform: translate(130px, 0); }
        .tile-position-3-2 { transform: translate(130px, 65px); }
        .tile-position-3-3 { transform: translate(130px, 130px); }
        .tile-position-3-4 { transform: translate(130px, 195px); }
        .tile-position-4-1 { transform: translate(195px, 0); }
        .tile-position-4-2 { transform: translate(195px, 65px); }
        .tile-position-4-3 { transform: translate(195px, 130px); }
        .tile-position-4-4 { transform: translate(195px, 195px); }
      }
    </style>
  </head>
  <body>
    <main>
      <header class="hero">
        <h1>FG 2048</h1>
        <nav aria-label="Primary">
          <a href="index.html">Home</a>
          <a href="index.html#about">About Me</a>
          <a href="index.html#contact">Get In Contact</a>
          <a href="index.html#resume">Resume</a>
          <a href="people.html">People</a>
        </nav>
      </header>

      <div class="game-container">
        <div class="heading">
          <h1 class="title">FG 2048</h1>
          <div class="scores-container">
            <div class="score-box">
              <div class="score-label">Score</div>
              <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
              <div class="score-label">Best</div>
              <div class="score-value" id="best-score">0</div>
            </div>
          </div>
        </div>
        <div class="above-game">
          <p class="game-intro">Join the tiles, get to <strong>2048</strong>!</p>
          <button class="restart-button" onclick="game.restart()">New Game</button>
        </div>
        <div class="game-layout">
          <div class="container">
            <div class="grid-container">
              <div class="grid-row">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
              </div>
              <div class="grid-row">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
              </div>
              <div class="grid-row">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
              </div>
              <div class="grid-row">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
              </div>
            </div>
            <div class="tile-container"></div>
            <div class="game-message" id="game-message">
              <p></p>
              <div class="lower">
                <button class="restart-button" id="keep-playing-button" onclick="game.continuePlaying()" style="display: none;">Keep playing</button>
                <button class="restart-button" onclick="game.restart()">Try again</button>
              </div>
            </div>
          </div>
          <aside class="leaderboard-panel" aria-live="polite" aria-label="Leaderboard">
            <div class="leaderboard-header">
              <h2>Leaderboard</h2>
              <p class="leaderboard-subtitle">Top 10 scores (local + cloud)</p>
            </div>
            <ol class="leaderboard-list" id="leaderboard-list"></ol>
            <p class="leaderboard-empty" id="leaderboard-empty">No scores yet — finish a game to claim your spot.</p>
          </aside>
        </div>
      </div>
    </main>

    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script>
      const TILE_IMAGE_MAP = {
        2: "2.png",
        4: "4.png",
        8: "8.png",
        16: "16.png",
        32: "32.png",
        64: "64.png",
        128: "128.png",
        256: "256.png",
        512: "512.png",
        1024: "1024.png",
        2048: "2048.png",
        default: "2048.png"
      };

      const LEADERBOARD_COOKIE_KEY = "fg2048Leaderboard";
      const MAX_LEADERBOARD_ENTRIES = 10;

      const firebaseConfig = {
        apiKey: "YOUR_API_KEY",
        authDomain: "YOUR_AUTH_DOMAIN",
        projectId: "YOUR_PROJECT_ID",
        storageBucket: "YOUR_STORAGE_BUCKET",
        messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
        appId: "YOUR_APP_ID"
      };

      let firestoreDb = null;

      function initializeFirebase() {
        if (typeof firebase === "undefined") {
          console.warn("Firebase SDK failed to load. Cloud leaderboard disabled.");
          return;
        }

        const hasPlaceholders = Object.values(firebaseConfig).some(function (value) {
          return typeof value === "string" && value.indexOf("YOUR_") === 0;
        });

        if (hasPlaceholders) {
          console.info("Update firebaseConfig with your Firebase project details to enable cloud sync.");
          return;
        }

        try {
          if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
          }
          firestoreDb = firebase.firestore();
        } catch (error) {
          console.warn("Firebase initialization failed:", error);
        }
      }

      initializeFirebase();

      function getCookieValue(name) {
        const cookie = document.cookie ? document.cookie.split("; ").find(function (row) {
          return row.startsWith(name + "=");
        }) : null;
        return cookie ? decodeURIComponent(cookie.split("=")[1]) : null;
      }

      function setCookieValue(name, value, days) {
        const expires = new Date(Date.now() + (days || 365) * 24 * 60 * 60 * 1000).toUTCString();
        document.cookie = name + "=" + encodeURIComponent(value) + "; expires=" + expires + "; path=/; SameSite=Lax";
      }

      function sanitizeName(name) {
        const trimmed = (name || "").trim();
        if (!trimmed) {
          return "";
        }
        return trimmed.substring(0, 30);
      }

      function normalizeEntry(entry) {
        if (!entry) {
          return null;
        }

        let timestampValue = entry.timestamp;

        if (entry.createdAt && typeof entry.createdAt.toDate === "function") {
          timestampValue = entry.createdAt.toDate().toISOString();
        } else if (entry.timestamp && entry.timestamp.seconds && entry.timestamp.nanoseconds) {
          const millis = entry.timestamp.seconds * 1000 + Math.round(entry.timestamp.nanoseconds / 1e6);
          timestampValue = new Date(millis).toISOString();
        }

        return {
          name: sanitizeName(entry.name) || "Anonymous",
          score: Number(entry.score) || 0,
          timestamp: timestampValue || new Date().toISOString()
        };
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) {
          return "";
        }

        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
          return "";
        }

        return date.toLocaleDateString(undefined, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }

      function LeaderboardManager(options) {
        this.listElement = options.listElement;
        this.emptyElement = options.emptyElement;
        this.localScores = this.loadLocalScores();
        this.remoteScores = [];
        this.promptLocked = false;
        this.db = firestoreDb;
        this.remoteUnsubscribe = null;
        this.render();
        this.subscribeToRemote();
      }

      LeaderboardManager.prototype.loadLocalScores = function () {
        const raw = getCookieValue(LEADERBOARD_COOKIE_KEY);
        if (!raw) {
          return [];
        }

        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return [];
          }
          return parsed.map(normalizeEntry).filter(Boolean).sort(this.sortEntries);
        } catch (error) {
          console.warn("Unable to parse leaderboard cookie:", error);
          return [];
        }
      };

      LeaderboardManager.prototype.persistLocalScores = function () {
        setCookieValue(LEADERBOARD_COOKIE_KEY, JSON.stringify(this.localScores), 365);
      };

      LeaderboardManager.prototype.sortEntries = function (a, b) {
        if (b.score === a.score) {
          return new Date(a.timestamp) - new Date(b.timestamp);
        }
        return b.score - a.score;
      };

      LeaderboardManager.prototype.getCombinedScores = function () {
        const combined = []
          .concat(this.localScores || [])
          .concat(this.remoteScores || [])
          .map(normalizeEntry)
          .filter(Boolean);

        combined.sort(this.sortEntries);
        return combined.slice(0, MAX_LEADERBOARD_ENTRIES);
      };

      LeaderboardManager.prototype.subscribeToRemote = function () {
        if (!this.db) {
          return;
        }

        try {
          this.remoteUnsubscribe = this.db
            .collection("Scores")
            .orderBy("score", "desc")
            .limit(50)
            .onSnapshot(
              (snapshot) => {
                this.remoteScores = snapshot.docs.map(function (doc) {
                  return normalizeEntry(doc.data());
                }).filter(Boolean);
                this.render();
              },
              (error) => {
                console.warn("Leaderboard listener error:", error);
              }
            );
        } catch (error) {
          console.warn("Failed to subscribe to remote leaderboard:", error);
        }
      };

      LeaderboardManager.prototype.qualifies = function (score) {
        if (!score || score <= 0) {
          return false;
        }
        if (this.localScores.length < MAX_LEADERBOARD_ENTRIES) {
          return true;
        }
        const lowest = this.localScores[this.localScores.length - 1];
        return score > (lowest ? lowest.score : 0);
      };

      LeaderboardManager.prototype.handlePotentialHighScore = function (score) {
        if (this.promptLocked) {
          return;
        }

        this.promptLocked = true;

        if (!this.qualifies(score)) {
          return;
        }

        const storedName = (function () {
          try {
            return window.localStorage ? localStorage.getItem("fg2048PlayerName") || "" : "";
          } catch (error) {
            return "";
          }
        })();

        const response = window.prompt("New high score! Enter your name for the leaderboard:", storedName);
        const name = sanitizeName(response);

        if (!name) {
          return;
        }

        try {
          if (window.localStorage) {
            localStorage.setItem("fg2048PlayerName", name);
          }
        } catch (error) {
          // Ignore localStorage errors
        }

        const entry = normalizeEntry({
          name: name,
          score: score,
          timestamp: new Date().toISOString()
        });

        this.addLocalEntry(entry);
        this.persistRemoteScore(entry);
      };

      LeaderboardManager.prototype.addLocalEntry = function (entry) {
        this.localScores = this.localScores.concat(entry);
        this.localScores.sort(this.sortEntries);
        this.localScores = this.localScores.slice(0, MAX_LEADERBOARD_ENTRIES);
        this.persistLocalScores();
        this.render();
      };

      LeaderboardManager.prototype.persistRemoteScore = function (entry) {
        if (!this.db) {
          return;
        }

        try {
          const payload = {
            name: entry.name,
            score: entry.score,
            timestamp: entry.timestamp,
            createdAt: firebase.firestore.FieldValue ? firebase.firestore.FieldValue.serverTimestamp() : entry.timestamp
          };
          this.db.collection("Scores").add(payload).catch(function (error) {
            console.warn("Failed to save remote score:", error);
          });
        } catch (error) {
          console.warn("Unable to write to Firestore:", error);
        }
      };

      LeaderboardManager.prototype.render = function () {
        if (!this.listElement) {
          return;
        }

        const entries = this.getCombinedScores();
        this.listElement.innerHTML = "";

        if (!entries.length) {
          if (this.emptyElement) {
            this.emptyElement.style.display = "block";
          }
          return;
        }

        if (this.emptyElement) {
          this.emptyElement.style.display = "none";
        }

        entries.forEach((entry, index) => {
          const item = document.createElement("li");
          item.className = "leaderboard-entry";

          const label = document.createElement("div");
          label.className = "leaderboard-label";

          const rankSpan = document.createElement("span");
          rankSpan.className = "leaderboard-rank";
          rankSpan.textContent = (index + 1) + ".";
          label.appendChild(rankSpan);

          const meta = document.createElement("div");
          meta.className = "leaderboard-meta";

          const nameSpan = document.createElement("span");
          nameSpan.className = "leaderboard-name";
          nameSpan.textContent = entry.name;
          meta.appendChild(nameSpan);

          const timestampText = formatTimestamp(entry.timestamp);
          if (timestampText) {
            const timeSpan = document.createElement("span");
            timeSpan.className = "leaderboard-timestamp";
            timeSpan.textContent = timestampText;
            meta.appendChild(timeSpan);
          }

          const scoreSpan = document.createElement("span");
          scoreSpan.className = "leaderboard-score";
          scoreSpan.textContent = entry.score.toLocaleString();

          label.appendChild(meta);
          item.appendChild(label);
          item.appendChild(scoreSpan);
          this.listElement.appendChild(item);
        });
      };

      LeaderboardManager.prototype.resetForActiveGame = function () {
        this.promptLocked = false;
      };

      LeaderboardManager.prototype.destroy = function () {
        if (this.remoteUnsubscribe) {
          this.remoteUnsubscribe();
          this.remoteUnsubscribe = null;
        }
      };

      // Game Manager
      function GameManager(size, InputManager, Actuator, StorageManager) {
        this.size = size;
        this.inputManager = new InputManager();
        this.storageManager = new StorageManager();
        this.actuator = new Actuator();

        this.startTiles = 2;

        this.inputManager.on("move", this.move.bind(this));
        this.inputManager.on("restart", this.restart.bind(this));
        this.inputManager.on("keepPlaying", this.continuePlaying.bind(this));

        this.setup();
      }

      GameManager.prototype.restart = function () {
        this.storageManager.clearGameState();
        this.actuator.continueGame();
        this.setup();
        if (window.leaderboardManager) {
          window.leaderboardManager.resetForActiveGame();
        }
      };

      GameManager.prototype.continuePlaying = function () {
        this.keepPlaying = true;
        this.actuator.continueGame();
      };

      GameManager.prototype.isGameTerminated = function () {
        if (this.over || (this.won && !this.keepPlaying)) {
          return true;
        }
        return false;
      };

      GameManager.prototype.setup = function () {
        var previousState = this.storageManager.getGameState();

        if (previousState) {
          this.grid = new Grid(previousState.grid.size, previousState.grid.cells);
          this.score = previousState.score;
          this.over = previousState.over;
          this.won = previousState.won;
          this.keepPlaying = previousState.keepPlaying;
        } else {
          this.grid = new Grid(this.size);
          this.score = 0;
          this.over = false;
          this.won = false;
          this.keepPlaying = false;

          this.addStartTiles();
        }

        this.actuate();
      };

      GameManager.prototype.addStartTiles = function () {
        for (var i = 0; i < this.startTiles; i++) {
          this.addRandomTile();
        }
      };

      GameManager.prototype.addRandomTile = function () {
        if (this.grid.cellsAvailable()) {
          var value = Math.random() < 0.9 ? 2 : 4;
          var tile = new Tile(this.grid.randomAvailableCell(), value);

          this.grid.insertTile(tile);
        }
      };

      GameManager.prototype.actuate = function () {
        if (this.storageManager.getBestScore() < this.score) {
          this.storageManager.setBestScore(this.score);
        }

        var metadata = {
          score: this.score,
          bestScore: this.storageManager.getBestScore(),
          over: this.over,
          won: this.won,
          terminated: this.isGameTerminated()
        };

        if (this.actuator.actuate) {
          this.actuator.actuate(this.grid, metadata);
        }

        if (window.leaderboardManager) {
          if (metadata.terminated) {
            window.leaderboardManager.handlePotentialHighScore(metadata.score);
          } else {
            window.leaderboardManager.resetForActiveGame();
          }
        }

        this.storageManager.setGameState(this.serialize());
      };

      GameManager.prototype.serialize = function () {
        return {
          grid: {
            size: this.grid.size,
            cells: this.grid.serialize()
          },
          score: this.score,
          over: this.over,
          won: this.won,
          keepPlaying: this.keepPlaying
        };
      };

      GameManager.prototype.prepareTiles = function () {
        this.grid.eachCell(function (x, y, tile) {
          if (tile) {
            tile.mergedFrom = null;
            tile.savePosition();
          }
        });
      };

      GameManager.prototype.moveTile = function (tile, cell) {
        this.grid.cells[tile.x][tile.y] = null;
        this.grid.cells[cell.x][cell.y] = tile;
        tile.updatePosition(cell);
      };

      GameManager.prototype.move = function (direction) {
        var self = this;

        if (this.isGameTerminated()) return;

        var cell, tile;

        var vector = this.getVector(direction);
        var traversals = this.buildTraversals(vector);
        var moved = false;

        this.prepareTiles();

        traversals.x.forEach(function (x) {
          traversals.y.forEach(function (y) {
            cell = { x: x, y: y };
            tile = self.grid.cellContent(cell);

            if (tile) {
              var positions = self.findFarthestPosition(cell, vector);
              var next = self.grid.cellContent(positions.next);

              if (next && next.value === tile.value && !next.mergedFrom) {
                var merged = new Tile(positions.next, tile.value * 2);
                merged.mergedFrom = [tile, next];

                self.grid.insertTile(merged);
                self.grid.removeTile(tile);

                tile.updatePosition(positions.next);

                self.score += merged.value;

                if (merged.value === 2048) self.won = true;
              } else {
                self.moveTile(tile, positions.farthest);
              }

              if (!self.positionsEqual(cell, tile)) {
                moved = true;
              }
            }
          });
        });

        if (moved) {
          this.addRandomTile();

          if (!this.movesAvailable()) {
            this.over = true;
          }

          this.actuate();
        }
      };

      GameManager.prototype.getVector = function (direction) {
        var map = {
          0: { x: 0, y: -1 },
          1: { x: 1, y: 0 },
          2: { x: 0, y: 1 },
          3: { x: -1, y: 0 }
        };

        return map[direction];
      };

      GameManager.prototype.buildTraversals = function (vector) {
        var traversals = { x: [], y: [] };

        for (var pos = 0; pos < this.size; pos++) {
          traversals.x.push(pos);
          traversals.y.push(pos);
        }

        if (vector.x === 1) traversals.x = traversals.x.reverse();
        if (vector.y === 1) traversals.y = traversals.y.reverse();

        return traversals;
      };

      GameManager.prototype.findFarthestPosition = function (cell, vector) {
        var previous;

        do {
          previous = cell;
          cell = { x: previous.x + vector.x, y: previous.y + vector.y };
        } while (this.grid.withinBounds(cell) && this.grid.cellAvailable(cell));

        return {
          farthest: previous,
          next: cell
        };
      };

      GameManager.prototype.movesAvailable = function () {
        return this.grid.cellsAvailable() || this.tileMatchesAvailable();
      };

      GameManager.prototype.tileMatchesAvailable = function () {
        var self = this;

        var tile;

        for (var x = 0; x < this.size; x++) {
          for (var y = 0; y < this.size; y++) {
            tile = this.grid.cellContent({ x: x, y: y });

            if (tile) {
              for (var direction = 0; direction < 4; direction++) {
                var vector = self.getVector(direction);
                var cell = { x: x + vector.x, y: y + vector.y };

                var other = self.grid.cellContent(cell);

                if (other && other.value === tile.value) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };

      GameManager.prototype.positionsEqual = function (first, second) {
        return first.x === second.x && first.y === second.y;
      };

      // Grid
      function Grid(size, previousState) {
        this.size = size;
        this.cells = previousState ? this.fromState(previousState) : this.empty();
      }

      Grid.prototype.empty = function () {
        var cells = [];

        for (var x = 0; x < this.size; x++) {
          var row = cells[x] = [];

          for (var y = 0; y < this.size; y++) {
            row.push(null);
          }
        }

        return cells;
      };

      Grid.prototype.fromState = function (state) {
        var cells = [];

        for (var x = 0; x < this.size; x++) {
          var row = cells[x] = [];

          for (var y = 0; y < this.size; y++) {
            var tile = state[x][y];
            row.push(tile ? new Tile(tile.position, tile.value) : null);
          }
        }

        return cells;
      };

      Grid.prototype.randomAvailableCell = function () {
        var cells = this.availableCells();

        if (cells.length) {
          return cells[Math.floor(Math.random() * cells.length)];
        }
      };

      Grid.prototype.availableCells = function () {
        var cells = [];

        this.eachCell(function (x, y, tile) {
          if (!tile) {
            cells.push({ x: x, y: y });
          }
        });

        return cells;
      };

      Grid.prototype.eachCell = function (callback) {
        for (var x = 0; x < this.size; x++) {
          for (var y = 0; y < this.size; y++) {
            callback(x, y, this.cells[x][y]);
          }
        }
      };

      Grid.prototype.cellsAvailable = function () {
        return !!this.availableCells().length;
      };

      Grid.prototype.cellAvailable = function (cell) {
        return !this.cellContent(cell);
      };

      Grid.prototype.cellContent = function (cell) {
        if (this.withinBounds(cell)) {
          return this.cells[cell.x][cell.y];
        } else {
          return null;
        }
      };

      Grid.prototype.insertTile = function (tile) {
        this.cells[tile.x][tile.y] = tile;
      };

      Grid.prototype.removeTile = function (tile) {
        this.cells[tile.x][tile.y] = null;
      };

      Grid.prototype.withinBounds = function (position) {
        return position.x >= 0 && position.x < this.size &&
          position.y >= 0 && position.y < this.size;
      };

      Grid.prototype.serialize = function () {
        var cellState = [];

        for (var x = 0; x < this.size; x++) {
          var row = cellState[x] = [];

          for (var y = 0; y < this.size; y++) {
            row.push(this.cells[x][y] ? this.cells[x][y].serialize() : null);
          }
        }

        return cellState;
      };

      // Tile
      function Tile(position, value) {
        this.x = position.x;
        this.y = position.y;
        this.value = value || 2;

        this.previousPosition = null;
        this.mergedFrom = null;
      }

      Tile.prototype.savePosition = function () {
        this.previousPosition = { x: this.x, y: this.y };
      };

      Tile.prototype.updatePosition = function (position) {
        this.x = position.x;
        this.y = position.y;
      };

      Tile.prototype.serialize = function () {
        return {
          position: {
            x: this.x,
            y: this.y
          },
          value: this.value
        };
      };

      // Input Manager
      function InputManager() {
        this.events = {};

        this.eventTouchstart = "touchstart";
        this.eventTouchmove = "touchmove";
        this.eventTouchend = "touchend";

        this.listen();
      }

      InputManager.prototype.on = function (event, callback) {
        if (!this.events[event]) {
          this.events[event] = [];
        }
        this.events[event].push(callback);
      };

      InputManager.prototype.emit = function (event, data) {
        var callbacks = this.events[event];
        if (callbacks) {
          callbacks.forEach(function (callback) {
            callback(data);
          });
        }
      };

      InputManager.prototype.listen = function () {
        var self = this;

        var map = {
          38: 0,
          39: 1,
          40: 2,
          37: 3,
          75: 0,
          76: 1,
          74: 2,
          72: 3
        };

        document.addEventListener("keydown", function (event) {
          var modifiers = event.altKey || event.ctrlKey || event.metaKey ||
            event.shiftKey;
          var mapped = map[event.which];

          if (!modifiers) {
            if (mapped !== undefined) {
              event.preventDefault();
              self.emit("move", mapped);
            }
          }

          if (event.which === 82) {
            self.restart(event);
          }
        });

        var retry = document.querySelector(".restart-button");
        retry.addEventListener("click", this.restart.bind(this));
        retry.addEventListener("touchend", this.restart.bind(this));

        var touchStartClientX, touchStartClientY;
        var gameContainer = document.querySelector(".grid-container");

        gameContainer.addEventListener("touchstart", function (event) {
          if (event.touches.length > 1) return;

          touchStartClientX = event.touches[0].clientX;
          touchStartClientY = event.touches[0].clientY;
          event.preventDefault();
        });

        gameContainer.addEventListener("touchmove", function (event) {
          event.preventDefault();
        });

        gameContainer.addEventListener("touchend", function (event) {
          if (event.touches.length > 0) return;

          var touchEndClientX = event.changedTouches[0].clientX;
          var touchEndClientY = event.changedTouches[0].clientY;

          var dx = touchEndClientX - touchStartClientX;
          var absDx = Math.abs(dx);

          var dy = touchEndClientY - touchStartClientY;
          var absDy = Math.abs(dy);

          if (Math.max(absDx, absDy) > 10) {
            self.emit("move", absDx > absDy ? (dx > 0 ? 1 : 3) : (dy > 0 ? 2 : 0));
          }
        });
      };

      InputManager.prototype.restart = function (event) {
        event.preventDefault();
        this.emit("restart");
      };

      InputManager.prototype.keepPlaying = function (event) {
        event.preventDefault();
        this.emit("keepPlaying");
      };

      // Actuator
      function Actuator() {
        this.tileContainer = document.querySelector(".tile-container");
        this.scoreContainer = document.getElementById("score");
        this.bestContainer = document.getElementById("best-score");
        this.messageContainer = document.querySelector(".game-message");
        this.keepPlayingButton = document.getElementById("keep-playing-button");

        this.score = 0;
      }

      Actuator.prototype.actuate = function (grid, metadata) {
        var self = this;

        window.requestAnimationFrame(function () {
          self.clearContainer(self.tileContainer);

          grid.cells.forEach(function (column) {
            column.forEach(function (cell) {
              if (cell) {
                self.addTile(cell);
              }
            });
          });

          self.updateScore(metadata.score);
          self.updateBestScore(metadata.bestScore);

          if (metadata.terminated) {
            if (metadata.over) {
              self.message(false);
            } else if (metadata.won) {
              self.message(true);
            }
          }
        });
      };

      Actuator.prototype.continueGame = function () {
        this.clearMessage();
      };

      Actuator.prototype.clearContainer = function (container) {
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
      };

      Actuator.prototype.applyTileImage = function (element, value) {
        var imageFile = TILE_IMAGE_MAP[value] || TILE_IMAGE_MAP.default;
        element.style.backgroundImage = "url('FG 2048/" + imageFile + "')";
      };

      Actuator.prototype.addTile = function (tile) {
        var self = this;

        var wrapper = document.createElement("div");
        var inner = document.createElement("div");
        var position = tile.previousPosition || { x: tile.x, y: tile.y };
        var positionClass = this.positionClass(position);

        var classes = ["tile", "tile-" + tile.value, positionClass];

        if (tile.value > 2048) {
          classes.push("tile-super");
        }

        this.applyClasses(wrapper, classes);
        this.applyTileImage(wrapper, tile.value);

        inner.classList.add("tile-inner");
        inner.textContent = tile.value;

        if (tile.previousPosition) {
          window.requestAnimationFrame(function () {
            classes[2] = self.positionClass({ x: tile.x, y: tile.y });
            self.applyClasses(wrapper, classes);
          });
        } else if (tile.mergedFrom) {
          classes.push("tile-merged");
          this.applyClasses(wrapper, classes);
          this.applyTileImage(wrapper, tile.value);

          tile.mergedFrom.forEach(function (merged) {
            self.addTile(merged);
          });
        } else {
          classes.push("tile-new");
          this.applyClasses(wrapper, classes);
          this.applyTileImage(wrapper, tile.value);
        }

        wrapper.appendChild(inner);
        this.tileContainer.appendChild(wrapper);
      };

      Actuator.prototype.applyClasses = function (element, classes) {
        element.setAttribute("class", classes.join(" "));
      };

      Actuator.prototype.normalizePosition = function (position) {
        return { x: position.x + 1, y: position.y + 1 };
      };

      Actuator.prototype.positionClass = function (position) {
        position = this.normalizePosition(position);
        return "tile-position-" + position.x + "-" + position.y;
      };


      Actuator.prototype.updateScore = function (score) {
        this.score = score;
        this.scoreContainer.textContent = score;
      };

      Actuator.prototype.updateBestScore = function (bestScore) {
        this.bestContainer.textContent = bestScore;
      };

      Actuator.prototype.message = function (won) {
        var type = won ? "game-won" : "game-over";
        var message = won ? "You win!" : "Game over!";

        this.messageContainer.classList.add(type);
        this.messageContainer.querySelector("p").textContent = message;
        this.messageContainer.style.display = "flex";

        if (this.keepPlayingButton) {
          this.keepPlayingButton.style.display = won ? "inline-block" : "none";
        }
      };

      Actuator.prototype.clearMessage = function () {
        this.messageContainer.classList.remove("game-won");
        this.messageContainer.classList.remove("game-over");
        this.messageContainer.style.display = "none";

        if (this.keepPlayingButton) {
          this.keepPlayingButton.style.display = "none";
        }
      };

      // Storage Manager
      function StorageManager() {
        this.bestScoreKey = "bestScore";
        this.gameStateKey = "gameState";

        var supported = this.localStorageSupported();
        this.storage = supported ? window.localStorage : window.fakeStorage;
      }

      StorageManager.prototype.localStorageSupported = function () {
        var testKey = "test";
        var storage = window.localStorage;

        try {
          storage.setItem(testKey, "1");
          storage.removeItem(testKey);
          return true;
        } catch (e) {
          return false;
        }
      };

      StorageManager.prototype.getBestScore = function () {
        return this.storage.getItem(this.bestScoreKey) || 0;
      };

      StorageManager.prototype.setBestScore = function (score) {
        this.storage.setItem(this.bestScoreKey, score);
      };

      StorageManager.prototype.getGameState = function () {
        var stateJSON = this.storage.getItem(this.gameStateKey);
        return stateJSON ? JSON.parse(stateJSON) : null;
      };

      StorageManager.prototype.setGameState = function (gameState) {
        this.storage.setItem(this.gameStateKey, JSON.stringify(gameState));
      };

      StorageManager.prototype.clearGameState = function () {
        this.storage.removeItem(this.gameStateKey);
      };

      StorageManager.getBestScore = function () {
        return new StorageManager().getBestScore();
      };

      // Fake Storage for browsers that don't support localStorage
      window.fakeStorage = {
        _data: {},
        setItem: function (id, val) {
          return this._data[id] = String(val);
        },
        getItem: function (id) {
          return this._data.hasOwnProperty(id) ? this._data[id] : undefined;
        },
        removeItem: function (id) {
          return delete this._data[id];
        },
        clear: function () {
          return this._data = {};
        }
      };

      window.leaderboardManager = new LeaderboardManager({
        listElement: document.getElementById("leaderboard-list"),
        emptyElement: document.getElementById("leaderboard-empty")
      });

      window.addEventListener("beforeunload", function () {
        if (window.leaderboardManager) {
          window.leaderboardManager.destroy();
        }
      });

      // Initialize the game
      window.requestAnimationFrame(function () {
        window.game = new GameManager(4, InputManager, Actuator, StorageManager);
      });
    </script>
  </body>
</html>

